/*
题目：
A string S of lowercase letters is given.
We want to partition this string into as many parts as possible so that each letter appears in at most one part,
and return a list of integers representing the size of these parts.
Example 1:
Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.
Note:
S will have length in range [1, 500].
S will consist of lowercase letters ('a' to 'z') only.
解析：
遍历S并记录每个字符出现的最后位置，如果某个字符a首次和最后出现的位置之间的所有字符x的最后出现位置都小于该字符a的最后出现位置，
那么就可以划分为一个子段，否则最后出现位置应变为更大的那个，继续该方法。
例如：a首次出现start=0，最后出现end=8，对S按照i进行检索，end应为前面检索过的字符最后出现索引的最大值。当i与end相等时，说明
所有字符都出现在i左侧，可以划分。注意返回值中为子段的元素个数，所以应为end-start+1,
*/
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int last[26]={0};
        int size=s.size();
        for(int i=0;i<size;i++)
            last[s[i]-'a']=i;//记录s中每个字符出现的最后索引，顺序为a-z
        int start=0,end=0;//记录首次出现和最后出现的索引
        vector<int> res;
        for(int i=0;i<size;i++)
        {
            end=max(end,last[s[i]-'a']);//从a首次出现到最后出现，记录其中出现过字符的最后出现位置
            //当最后出现位置与字符在s中的索引相同时，说明所有字符均在左侧出现,可以分割
            //如defegde，d的最后出现索引比e小，所以只有当检索到e最后出现的i与最后索引相同时，才可以划分
            if(i==end)
            {
                res.push_back(end-start+1);
                start=end+1;//从下一个子段开始检索
            }
        }
        return res;
    }
};
