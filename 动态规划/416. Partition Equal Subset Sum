/*
题目
Given a non-empty array containing only positive integers, find if the array can be partitioned into two 
subsets such that the sum of elements in both subsets is equal.
Note:
Each of the array element will not exceed 100.
The array size will not exceed 200.
Example 1:
Input: [1, 5, 11, 5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
Example 2:
Input: [1, 2, 3, 5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
解析：
给定一个数组 数组中的数字均为正数 将数组分为两个数组 使其和相等。
0-1背包的变体 在这里每个数字只有一个属性 即其值大小。将数组的值求和，若和不为2的倍数
则数组肯定不能分割成两个和相等的数组。若和为2的倍数，从数组中任意选取数字，只要其和为sum/2，
则数组可以分割，否则不能分割。
记dp[i][j]为数组前i个元素，从中任选k<=i，其和可否为j,可以为j的话true，否则false
那么根据j和nums[i]的关系，dp[i][j]=dp[i-1][j] j<=nums[i]，j小的话，必不选nums[i]，前i个元素能否组成j与前i-1个元素
能否组成j相同。dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i]]，如果j不小于nums[i]的话，只要前i-1个元素能组成j，那么不选nums[i]
即可，或者前i-1个元素不能组成j，又j>nums[i]，那么就要判断选i之后，和是否为j，即dp[i-1][j-nums[i]]是否为true。
因为选了nums[i]当前和能组成j，说明前i-1个元素的和能组成j-nums[i]。
因为从数组第一个元素开始到最后一个元素，数组索引0-n-1，但是初值dp[0][0]为true，所以数组索引必须-1.
即dp[i][j]=dp[i-1][j],j<=nums[i-1]
  dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i-1]],j>nums[i-1]
*/
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sizeNums=nums.size();
        int sum=0;
        for(int i=0;i<sizeNums;i++)
            sum+=nums[i];
        if(sizeNums==0||sum%2!=0)
            return false;
        sum/=2;
        vector<vector<bool>> dp(sizeNums+1,vector<bool>(sum+1,false));
        for(int i=0;i<=sizeNums;i++)
                dp[i][0]=true;
        for(int i=1;i<=sizeNums;i++)
        {
            bool cur=false;
            for(int j=0;j<=sum;j++)
            {
                if(dp[i-1][j])
                    cur=true;
                else
                {
                    if(j>=nums[i-1]&&dp[i-1][j-nums[i-1]])
                        cur=true;
                    else
                        cur=false;
                }
                 dp[i][j]=cur;
            }
        }
        return dp[sizeNums][sum];
    }
};
