/*
题目
Given a non-empty array containing only positive integers, find if the array can be partitioned into two 
subsets such that the sum of elements in both subsets is equal.
Note:
Each of the array element will not exceed 100.
The array size will not exceed 200.
Example 1:
Input: [1, 5, 11, 5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
Example 2:
Input: [1, 2, 3, 5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
解析：
给定一个数组 数组中的数字均为正数 将数组分为两个数组 使其和相等。
0-1背包的变体 在这里每个数字只有一个属性 即其值大小。将数组的值求和，若和不为2的倍数
则数组肯定不能分割成两个和相等的数组。若和为2的倍数，从数组中任意选取数字，只要其和为sum/2，
则数组可以分割，否则不能分割。
记dp[i][j]为数组前i个元素，从中任选k<=i，其和可否为j,可以为j的话true，否则false
那么根据j和nums[i]的关系，dp[i][j]=dp[i-1][j] j<=nums[i]，j小的话，必不选nums[i]，前i个元素能否组成j与前i-1个元素
能否组成j相同。dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i]]，如果j不小于nums[i]的话，只要前i-1个元素能组成j，那么不选nums[i]
即可，或者前i-1个元素不能组成j，又j>nums[i]，那么就要判断选i之后，和是否为j，即dp[i-1][j-nums[i]]是否为true。
因为选了nums[i]当前和能组成j，说明前i-1个元素的和能组成j-nums[i]。
因为从数组第一个元素开始到最后一个元素，数组索引0-n-1，但是初值dp[0][0]为true，所以数组索引必须-1.
即dp[i][j]=dp[i-1][j],j<=nums[i-1]
  dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i-1]],j>nums[i-1]
*/
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        if(nums.empty())
            return false;
        int sum=0;
        int size=nums.size();
        for(int i=0;i<size;i++)
            sum+=nums[i];
        if(sum%2!=0)
            return false;
        sum=sum/2;
        vector<vector<bool>> dp(size+1,vector<bool>(sum+1,false));//dp[i][j]，前i个任选可否和为j
        //这里0代表从选0个和为sum 所以从n个里选sum，dp应为(size+1)x(sum+1)
        for(int i=1;i<size+1;i++)
            dp[i][0]=true;//i个中任选组成0，其中有0或是一个都不选可以和为0，因此为true
        for(int i=1;i<sum+1;i++)
            dp[0][i]=false;//0个怎么选和都不可能为i（i>=1），因此false
        dp[0][0]=true;//0个中选出0可以实现
        for(int i=1;i<size+1;i++)
            for(int j=1;j<sum+1;j++)
            {
                if(j>=nums[i-1])
                    dp[i][j]=(dp[i-1][j]||dp[i-1][j-nums[i-1]]);//j>=nums[i-1]，nums[i-1]可选，因此考虑选i和不选i，只要一个符合即可。
                else
                    dp[i][j]=dp[i-1][j];//j<nums[i-1]，nums[i-1]必不可选，因此与前i-1个的情况相同。
            }
        return dp[size][sum];//前size个能否组成sum
    }
};
