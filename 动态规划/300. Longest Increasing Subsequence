/*
题目：
Given an unsorted array of integers, find the length of longest increasing subsequence.
Example:
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
Note:
There may be more than one LIS combination, it is only necessary for you to return the length.
Your algorithm should run in O(n2) complexity.
Follow up: Could you improve it to O(n log n) time complexity?
解析：
给定一个数组，求其中连续递增子序列的最大长度。
动态规划问题。
假设s(k)为选取第k个数字时的最大连续子序列的长度，则有：
s(k)= max(s(i)+1) i<k,a(i)<a(k)
k个元素的值为a(k),其前面k-1个数值有比a(k)小的值。
比a(k)小的，则s(k)=s(i)+1,取其最大值作为当前元素的最大递增子序列。
10 9 2 5 3 7 101 18
k    a(k)   s(k)
1    10     1
2    9      1
3    2      1
4    5      2   比5小的有2，长度+1 max=2
5    3      2   比3小的有2，长度+1 max=2
6    7      3   比7小的有2,3,5，长度+1 max=3
7    101    4   同理，max=4
8    18     4   同理  max=4
9    1      1   因为没有比1小的，所以此处max=1
由此可见，最后的输出结果应该是max(dp[i])，而不是dp的最后一个元素
*/

class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.empty())
            return 0;//预处理
        int size=nums.size();
        vector<int>dp(size,1);//初值设为1，因为一个数字如果之前没有比他小的数字，那么递增子序列的长度为1
        int res=dp[0];//res初值，取dp所有值的最大值
        for(int i=1;i<size;i++)
        {
            for(int j=0;j<i;j++)//判断k元素之前的所有元素
            {
                if(nums[i]>nums[j])//比k元素小，则递增子序列+1，取其最大值
                    dp[i]=max(dp[i],dp[j]+1);
            }
            res=max(res,dp[i]);//res取dp中最大值
        }
        return res;
    }
};
