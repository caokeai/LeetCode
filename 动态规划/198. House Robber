/*
题目：
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, 
the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and 
it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of 
money you can rob tonight without alerting the police.
Example 1:
Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
Example 2:
Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
解析：
盗贼问题，连续的数组，从中选取不相邻的数字，使数字的和最大。
使用动态规划法来求解。
假设选取了第k个数值，则只能再选取k-2或k-3中的最大值。
k=1时，dp[0]=nums[0]
k=2时，dp[1]=nums[1]
k=3时，抢劫了nums[2]，因为相邻的不能抢，因此为保证和最大，只能再抢nums[0]
这样递推下去后，数组最后两个数的最大值即是求的数字最大和。因为不能抢相邻的，所以
不能保证数组最后一个元素即是最大值。
*/
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.empty())
            return 0;//预判断
        int size=nums.size();
        if(size==1)
            return nums[0];//只有一个元素
        if(size==2)
            return max(nums[0],nums[1]);//只有两个元素，返回其中的大值
        vector<int> dp(size,0);
        dp[0]=nums[0];//抢劫了1
        dp[1]=nums[1];//抢劫了2
        dp[2]=nums[0]+nums[2];//抢劫了3，所以只能再抢1
        for(int i=3;i<size;i++)
            dp[i]=max(dp[i-2],dp[i-3])+nums[i];//递推公式
        if
        return max(dp[size-1],dp[size-2]);//因为相邻的没有判断大小，所以最后两个不能保证哪个更大
    }
};
