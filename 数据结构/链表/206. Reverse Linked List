/*
题目：
Reverse a singly linked list.
Example:
Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
解析：
采用头插法反转链表。需要记录三个变量：
当前节点p（按原链表顺序遍历）
下个节点nxt（原链表的下个节点，因为修改了链表当前节点的下个节点，所以需要保存，使得节点遍历按原链表顺序进行）
上个节点res（pre，从NULL开始，保存当前节点p的值，作为下次修改p+1节点的下一个节点p）
如 1->2->3->4->5->NULL
round1：保存1的原指向节点2，1节点的原指向打断，指向res的初值NULL，res保存当前节点1作为下个节点2的指向
...
*/
//方法一： 头插法 如上解析所示
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* res=NULL;//需要设初值为NULL，不可省略
        ListNode* p=head;
        while(p!=NULL)
        {
            ListNode* nxt=p->next;//保留当前节点的下一个节点
            p->next=res;//修改当前节点指向前一个节点
            res=p;//保留下次修改的前节点
            p=nxt;//p遍历原链表
        }
        return res;//实际上res与p同变化，但是p遍历到了NULL
    }
};
//方法二 使用stack的LIFO特性 原链表依次入栈 到链表尾后 出栈重建链表
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==NULL)
            return head;//空链表判断
        ListNode* p=head;//不对输入做修改
        stack<ListNode*> st;//辅助栈
        while(p!=NULL)
        {
            st.push(p);//原链表入栈
            p=p->next;
        }
        ListNode* res=new ListNode(1);//声明链表节点时一定要用ListNode(int)，不能赋NULL，否则没有空间，不能访问res->next
        ListNode* pp=res;//res保存结果的链表头，用res副本pp重建链表，最后输出res->next即可。
        while(!st.empty())
        {
            ListNode* temp= new ListNode(st.top()->val);//新节点
            pp->next=temp;//做为新链表的后节点
            pp=pp->next;//当前节点向后移动
            st.pop();//出栈
        }
        pp->next=NULL;//链表尾添加NULL
        return res->next;//这样重建后，因为声明新链表的时候，首节点必须有值，所以最后链表为1->5->4->3->2->1->NULL,首节点为自定义的值
                         //所以要输出首节点的下一个节点。
    }
};
