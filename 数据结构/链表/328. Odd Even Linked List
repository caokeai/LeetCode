/*
题目：
Given a singly linked list, group all odd nodes together followed by the even nodes. 
Please note here we are talking about the node number and not the value in the nodes.
You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.
Example 1:
Input: 1->2->3->4->5->NULL
Output: 1->3->5->2->4->NULL
Example 2:
Input: 2->1->3->5->6->4->7->NULL
Output: 2->3->6->7->1->5->4->NULL
Note:
The relative order inside both the even and odd groups should remain as it was in the input.
The first node is considered odd, the second node even and so on ...
解析：
这里是将每个节点的下个节点变为下个节点的下个节点。从而将奇数位置和偶数位置的放在一起。
利用一个指针就能完成这个顺序操作，只要每次断链之前保存当前节点的下个节点。但是这样遍历完之后，
1->3->5  2->4 无法确定奇数节点的最后一个5从而无法将奇数链的结尾指向偶数链的开始。这里偶数链
的开始一定是head->next,所以只需要确定奇数链的结尾即可。
链表的节点数目只有奇数和偶数两种，因为偶数位置在后，所以使用偶数位置做为结尾判定
如1->2->3->4->5->NULL， 
round1:1->3 2->4
round2:3->5 4->NULL 
1->2->3->4->NULL
round1:1->3 2->4
round2 4的下一个为NULL 结束。
*/
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head==NULL||head->next==NULL)
            return head;//预判断 空或单节点直接返回即可
        ListNode* odd=head;//奇数位置起点
        ListNode* even=head->next;//偶数位置起点
        ListNode* evenHead=head->next;//这里使用一个变量储存偶数起点 因为对奇数位置下个节点修改了原来偶数位置的起点
        while(even!=NULL&&even->next!=NULL)
        {
            odd->next=odd->next->next;
            odd=odd->next;
            even->next=even->next->next;
            even=even->next;
        }
        odd->next=evenHead;//奇数位置链的末尾指向偶数位置链
        return head;//返回原链头即可
    }
};
