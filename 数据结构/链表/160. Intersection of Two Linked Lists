/*
题目：
Write a program to find the node at which the intersection of two singly linked lists begins.
For example, the following two linked lists:
Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
Output: Reference of the node with value = 8
Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). 
From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. 
There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
解析：
给定两个单向链表，判断两个链表是否有交点，若有则输出该节点，否则输出空。
A：1-2-1-4-5-8
     a+c       
B:   2-3-4-5-8
     b+c
假设有交点，且公共段为c，a=A-c，b=B-c，那么有a+c+b=b+c+a；即A+b=B+a;
设两个指针pa和pb同时从A和B的起点出发，pa遍历A，若到A结尾，则从B起点出发
pb遍历b，若到B结尾，则从A起点出发。直至两个指针相等。若指针非空，则AB有
且指针为交点，否则无交点。pa到达B结尾，pb到达a结尾。
*/
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==NULL||headB==NULL)
            return NULL;
        ListNode* pa=headA;//pa从A起点出发
        ListNode* pb=headB;//pb从B起点出发
        while(pa!=pb)//直至pa与pb相等
        {
            if(pa==NULL)
                pa=headB;//pa遍历A，若到A结尾，再遍历B
            else
                pa=pa->next;
            if(pb==NULL)
                pb=headA;//pb遍历B，若到B结尾，再遍历A
            else
                pb=pb->next;
        }
        return pa;
    }
};
